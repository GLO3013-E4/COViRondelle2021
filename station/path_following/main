#!/usr/bin/env python3
import rospy
import json
import math


from std_msgs.msg import String
from geometry_msgs.msg import PoseStamped
from nav_msgs.msg import Path
from path_following.config import NODE_SIZE
from path_following.vectorizer import Vectorizer
from path_following.destination import Destination


class PathFollower:
    def __init__(self):
        self.robot = None
        self.robot_angle = None
        self.path = []
        self.node_size = NODE_SIZE
        self.vectorizer = Vectorizer(minimize=True)
        self.vectorizer.set_destination(Destination.PUCK)
        self.rate = rospy.Rate(1)
        self.cm_to_pixel = self.vectorizer.cm_to_pixel

        self.pub = rospy.Publisher('movement_vectors_string', String, queue_size=10)
        rospy.Subscriber('robot', String, self.callback_robot)
        rospy.Subscriber('move_base_simple/goal', PoseStamped, self.callback_goal)
        rospy.Subscriber('path', Path, self.callback_path)

    def callback_robot(self, data):
        robot_dict = json.loads(data.data)

        self.vectorizer.set_robot_position(robot_dict["robot"])
        self.vectorizer.set_robot_angle(robot_dict["angle"])

    def callback_goal(self, data):
        self.vectorizer.set_goal((data.pose.position.x, data.pose.position.y))

    def callback_path(self, data):
        nodes = []
        for coordinate in data.poses:
            x = coordinate.pose.position.x
            y = coordinate.pose.position.y
            nodes.append((x, y))

        self.vectorizer.set_path(nodes)

        vectors = self.vectorizer.path_to_vectors()

        while vectors != []:
            try:
                distance, angle, mode = vectors[0]
                # vectors = [(distance/self.cm_to_pixel, self.convert_angle_to_driver_angle(angle), mode.value) for distance, angle, mode in vectors]
                published_vector = (distance/self.cm_to_pixel, self.convert_angle_to_driver_angle(angle), mode.value)
            except IndexError:
                rospy.logerr("Could not follow path")
                break

            self.pub.publish(json.dumps(published_vector))
            vectors = self.vectorizer.path_to_vectors()
            self.rate.sleep()

    def convert_angle_to_driver_angle(self, angle):
        angle = math.degrees(angle)

        if angle < 0:
            angle += 360
        return angle


def path_follower():
    rospy.init_node('path_following', anonymous=True)

    pathfollower = PathFollower()

    rate = rospy.Rate(10)  # 10hz

    rospy.spin()


if __name__ == '__main__':
    try:
        path_follower()
    except rospy.ROSInterruptException:
        pass
